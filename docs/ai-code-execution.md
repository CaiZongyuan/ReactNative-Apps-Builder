# AI 代码执行机制与局限性分析

本文档详细介绍了本项目如何实现 AI 生成代码的直接运行，以及当前方案的局限性。

## 一、 实现原理

核心机制在于“运行时编译 + 虚拟环境模拟”，主要步骤如下：

1.  **实时转译 (Transpilation)**：
    使用 `@babel/standalone` 在运行时将 AI 生成的 JSX、TypeScript 或 ES Modules 代码转换为普通的 JavaScript（ES5/ES6）。

2.  **模块环境模拟**：
    通过构造一个字符串函数，手动注入 `module` 和 `exports` 对象，模拟 CommonJS 模块环境。

3.  **依赖项注入 (Dependency Injection)**：
    实现了一个简易的 `require` 函数，将应用中已有的 `react`、`react-native` 和 `@instantdb/react-native` 实例注入到执行环境中。

4.  **动态执行**：
    使用 `new Function` 构造执行器，传入预设好的库实例，并获取 AI 代码中导出的组件进行渲染。

---

## 二、 局限性

虽然该机制实现了高度的灵活性，但也存在以下限制：

1.  **依赖库受限**：
    由于 `require` 是硬编码的，AI 只能使用预先注入的库。无法动态安装或使用其他第三方 npm 包。

2.  **原生模块限制**：
    无法使用未预先打包进 App 的原生功能（Native Modules）。

3.  **性能开销**：
    每次代码变更都需要经过 Babel 实时全量转译，复杂组件可能产生感知到的延迟。

4.  **调试成本高**：
    报错堆栈常指向 `new Function` 内部，难以精准定位源代码行号。

5.  **安全风险**：
    `new Function` 沙盒隔离性弱，理论上存在访问宿主应用敏感数据的风险。

6.  **单文件局限**：
    目前仅支持单文件导出，不支持跨文件的模块导入逻辑。
